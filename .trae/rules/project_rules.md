1. think in English，Write in Chinese
2. 遵守奥卡姆剃刀法则（Occam's Razor）和KISS法则，用最小的代码改动，实现最简洁的解决方案。
3. ！！！禁止使用mock服务！！！
4. 路径，请使用相对路径，禁止硬编码文件或包的路径。
5. 文件编码采用 UTF-8 编码

## 理念

### 架构与规划

- **架构先行，迭代开发**：在编写任何代码之前，必须先对功能进行宏观规划。首先识别核心功能，构建最小可用产品（MVP），然后通过迭代快速交付价值。
- **模块化与分层**：设计时应遵循高内聚、低耦合的原则。将系统划分为独立的模块（如数据、服务、接口），明确各层职责，减少依赖。
- **面向未来，而非过度设计**：代码设计应具备一定的扩展性，以适应未来可能的需求变化。但要避免过度工程化，禁止为尚未出现的需求构建复杂的解决方案。

### 错误处理

- **快速失败**：对于关键配置（如缺少文本模型），立即失败。当数据结构不符合预期时（例如，预期的字典却得到一个列表），应立即抛出类型错误，而不是尝试静默恢复。这能防止错误在系统中传递，导致后期更难调试的bug。
- **记录并继续**：对于可选功能（如提取模型），记录日志并继续运行。
- **优雅降级**：当外部服务不可用时，能够平稳地降低功能。
- **用户友好的消息**：通过弹性层向用户提供易于理解的信息。

## 绝对规则

- **主动复用，禁止重复**：在编写新代码前，必须主动搜索现有代码库以复用函数、类和常量。重复的代码是技术债务的根源。
- **禁止不完整的实现**：功能要么完全实现，要么完全不实现。禁止留下 `// TODO` 或未完成的逻辑。
- **禁止简化**：不要出现 `// 这只是简化的实现，完整的实现应该...` 之类的注释。
- **禁止死代码**：要么使用，要么从代码库中完全删除。
- **禁止隐式假设**：绝不假设外部数据（如文件、API响应）的编码、格式或结构。始终进行显式验证和转换（使用Pydantic），对所有外部输入贯彻“零信任”原则。
- **禁止命名不一致**：阅读现有代码库的命名模式，保持风格统一。
- **禁止职责混淆**：不要将验证逻辑放在 API 处理器里，或将数据库查询放在 UI 组件里，等等。应保持恰当的关注点分离。
- **禁止资源泄漏**：不要忘记关闭数据库连接、清除定时器、移除事件监听器或清理文件句柄。
- **禁止不完整的接口变更**：当修改函数签名时，必须更新所有调用点。使用IDE的"查找所有引用"功能确保没有遗漏。
- **禁止假设调用兼容性**：重构函数时，不能假设所有调用点都会自动适配。必须显式验证每个调用点的兼容性。
- **禁止跳过调用点验证**：重构函数时，即使IDE显示"无引用"，也要通过全局搜索（grep/ripgrep）验证，防止动态调用或字符串拼接调用被遗漏。
- **强制接口一致性**：同一类型的函数必须保持一致的参数签名、返回值类型和错误处理方式。这是函数可组合性的基础。
- **禁止硬编码工作流**：复合操作的执行顺序和参数应可配置，避免将业务逻辑硬编码在实现中。

### 命令行工具设计

- **组合优于继承**：复杂工作流应通过函数组合实现，而非继承。每个独立命令应有清晰的单一职责，复合命令通过调用独立命令的核心函数来实现功能组合。
- **统一函数接口**：同类型的核心函数应保持一致的参数签名和返回值约定。这确保了函数的可组合性和可预测性。
- **双重使用模式**：为用户提供两种使用方式 - 分步执行（精细控制）和一键完成（便捷操作）。满足不同场景下的使用需求。
- **参数透传设计**：复合命令应支持向子步骤传递关键参数，避免功能受限。通过 `**kwargs` 或显式参数实现灵活的参数传递。

### 工作流组合原则

- **状态管理**：复合工作流应记录每个步骤的执行状态，支持断点续传和错误恢复。
- **错误边界**：每个步骤应有明确的错误边界，失败时提供清晰的错误信息和恢复建议。
- **进度可视化**：长时间运行的工作流应提供清晰的进度反馈，让用户了解当前执行状态。
- **可配置性**：通过配置文件或命令参数支持工作流的定制化，避免硬编码的执行逻辑。

## 错误恢复

如果任何步骤失败：

- 清晰地解释问题所在。
- 提供具体的修复步骤。
- 绝不留下部分完成或损坏的文件。
